# Design Options: CI/CD 전략 및 파이프라인 설계

## 📋 개요
**기능**: 코드 품질 자동 검증(Test/Lint) 및 배포 자동화(CD) 파이프라인 구축
**작성일**: 2026-01-10
**상태**: ✅ 결정 완료

---

## 🎯 요구사항

### 필수 요구사항
- [x] **자동 테스트 및 린트**: 코드 변경 시(PR/Push) 자동으로 테스트 및 스타일 검사 수행
- [x] **커버리지 리포트**: Codecov와 연동하여 테스트 커버리지 시각화 (`secrets.CODECOV_TOKEN`)
- [x] **서버 배포 자동화**: 검증된 코드를 운영 서버에 배포
- [x] **SSH 기반 배포**: 복잡한 에이전트 설치 없이 SSH 명령으로 배포 수행

### 선택 요구사항
- [x] **Docker Image Registry**: 이미지를 저장할 레지스트리 선정 (GHCR 등)
- [ ] **무중단 배포**: Blue/Green 또는 Rolling Update (현재 단일 서버라 선택사항)

---

## 🔀 구현 방안 비교

### 방안 A: GitHub Actions + GHCR + SSH (권장)

**설명**: GitHub 생태계를 최대한 활용하는 방식. CI는 GitHub Actions에서 실행하고, 빌드된 이미지는 GHCR(GitHub Container Registry)에 저장하며, 배포는 `appleboy/ssh-action`을 사용해 서버에서 `docker compose pull && up`을 실행한다.

| 항목 | 내용 |
|------|------|
| **구현 난이도** | 낮음 |
| **예상 시간** | 2시간 |
| **유지보수** | 쉬움 |
| **확장성** | 보통 (단일 서버에 최적) |

**장점**:
- **통합성**: GitHub 내에서 코드, 이슈, 패키지, 액션을 모두 관리 가능.
- **비용 효율**: GitHub Actions Free Tier 및 GHCR 무료 사용 가능 (Public/Private 정책 확인 필요).
- **간편한 인증**: `GITHUB_TOKEN`을 사용하여 별도 자격 증명 관리가 최소화됨.
- **빠른 설정**: `appleboy/ssh-action` 등 검증된 액션 활용.

**단점**:
- GHCR은 Docker Hub보다 대중적 인지도가 낮을 수 있음 (사용상 차이는 거의 없음).
- 단일 서버 배포 방식이므로 아주 짧은 다운타임(컨테이너 재시작 시간)이 발생할 수 있음.

**필요한 것**:
- GitHub Repository Secrets (`CODECOV_TOKEN`, `HOST`, `USERNAME`, `KEY`)

---

### 방안 B: Jenkins + Docker Hub + Webhook

**설명**: 별도의 Jenkins 서버를 구축하여 CI/CD를 수행하고, Docker Hub에 이미지를 저장하며, Webhook을 통해 배포 서버에 알림을 보내 배포를 트리거하는 방식.

| 항목 | 내용 |
|------|------|
| **구현 난이도** | 높음 |
| **예상 시간** | 5시간+ |
| **유지보수** | 어려움 (Jenkins 서버 관리 필요) |
| **확장성** | 좋음 (복잡한 파이프라인 구성 가능) |

**장점**:
- **유연성**: 플러그인을 통해 거의 모든 종류의 파이프라인 구성 가능.
- **독립성**: 소스 코드 저장소 플랫폼(GitHub)에 종속되지 않음.

**단점**:
- **관리 비용**: Jenkins 마스터/슬레이브 노드를 직접 관리해야 함.
- **리소스 소모**: 별도의 서버 리소스 필요.

**필요한 것**:
- Jenkins 서버, Docker Hub 계정

---

### 방안 C: Cloud Base (AWS CodePipeline + ECR + ECS)

**설명**: AWS의 관리형 서비스를 전면적으로 사용하는 방식.

| 항목 | 내용 |
|------|------|
| **구현 난이도** | 중간 |
| **예상 시간** | 4시간 |
| **유지보수** | 보통 (AWS 콘솔 관리) |
| **확장성** | 좋음 (클라우드 네이티브) |

**장점**:
- **확장성**: 트래픽 증가 시 쉽게 스케일 아웃 가능.
- **안정성**: AWS 인프라의 안정성 활용.

**단점**:
- **비용**: ECR 스토리지, Build 시간, ECS 리소스 등 비용 발생.
- **복잡도**: 현재 단일 서버(EC2 or Lightsail) 구조에는 과도한 엔지니어링(Over-engineering).

**필요한 것**:
- AWS 계정, IAM 설정

---

### 방안 D: GitHub Actions Self-hosted Runner (강력 추천) 🏆

**설명**: 배포할 서버(VPS)에 GitHub Actions Runner 에이전트를 설치하여 직접 실행하는 방식. 외부에서 SSH로 접속할 필요 없이, Runner가 내부에서 직접 빌드하고 배포한다.

| 항목 | 내용 |
|------|------|
| **구현 난이도** | 낮음 |
| **예상 시간** | 1시간 |
| **유지보수** | 쉬움 (Runner 자동 업데이트) |
| **확장성** | 낮음 (서버 종속적) |

**장점**:
- **보안성**: 외부(GitHub 서버)에서 내부 서버로 SSH 접속을 열어줄 필요가 없음. Firewall 설정 간소화.
- **성능**: 로컬 캐시를 활용하므로 빌드 속도가 매우 빠름.
- **단순함**: 복잡한 SSH Action, Key 관리 불필요. `docker compose up`을 로컬 명령어처럼 실행 가능.

**단점**:
- **서버 리소스**: 빌드 시 서버 CPU/RAM을 사용하므로 서비스에 일시적 부하를 줄 수 있음 (리소스 제한 필요).
- **보안 주의**: Public Repository인 경우 Fork PR 공격에 취약할 수 있음 (현재 Private 또는 관리된 환경이라 가정).

**필요한 것**:
- 배포 서버에 Runner 설치

---

### 방안 E: Docker Context over SSH

**설명**: GitHub Actions Runner에서 `DOCKER_HOST` 환경변수를 설정하여, 원격 서버의 Docker Daemon을 마치 로컬 대몬처럼 제어하는 방식.

| 항목 | 내용 |
|------|------|
| **구현 난이도** | 중간 |
| **예상 시간** | 2시간 |
| **유지보수** | 쉬움 |
| **확장성** | 보통 |

**장점**:
- **깔끔함**: 로컬에서 `docker compose up` 하듯이 명령어를 실행하면 원격 서버에 배포됨.
- **무임승차**: 별도의 배포 스크립트나 에이전트 설치 없이 Docker Native 기능 활용.

**단점**:
- **보안**: Docker Socket 권한을 가진 SSH 접속을 열어야 하므로 보안 리스크가 큼 (Root 권한과 유사).
- **네트워크**: 로컬 빌드 컨텍스트 전송 시간이 걸릴 수 있음.

---

### 방안 F: Watchtower (Polling 방식)

**설명**: 서버에 `watchtower` 컨테이너를 실행해두고, 주기적으로(Polling) 레지스트리(GHCR)를 확인하여 새 이미지가 있으면 자동으로 컨테이너를 재시작하는 방식.

| 항목 | 내용 |
|------|------|
| **구현 난이도** | 매우 낮음 |
| **예상 시간** | 30분 |
| **유지보수** | 매우 쉬움 |
| **확장성** | 낮음 |

**장점**:
- **CI 독립성**: 배포 로직이 CI 파이프라인과 완전히 분리됨. CI는 이미지만 푸시하면 끝.
- **설정 간소화**: `docker-compose.yml`에 라벨 몇 개만 추가하면 됨.

**단점**:
- **제어권 부족**: 배포 시점(즉시 배포 등)을 정확히 제어하기 어려움.
- **실패 감지**: 배포 실패 시 CI 파이프라인에서 알림을 받기 어려움.

---

### 방안 G: Git Pull Deployment (Source Build)

**설명**: 서버에서 코드를 직접 받아서(`git pull`) 현장에서 빌드(`docker compose up --build`)하는 전통적인 방식.

| 항목 | 내용 |
|------|------|
| **구현 난이도** | 낮음 |
| **예상 시간** | 1시간 |
| **유지보수** | 보통 |
| **확장성** | 매우 나쁨 |

**장점**:
- **단순성**: 레지스트리(Push/Pull) 과정이 필요 없음.

**단점**:
- **서버 부하**: 운영 서버에서 빌드를 수행하므로 CPU/메모리 점유율이 폭주할 수 있음.
- **롤백 어려움**: 이전 버전 이미지로 즉시 되돌리기(Rollback)가 어렵고 다시 빌드해야 함.

---

## 📊 비교 요약

| 기준 | 방안 A (GH SaaS) | 방안 B (Jenkins) | 방안 D (Self-hosted) | 방안 E (Context) | 방안 F (Watchtower) |
|------|--------|--------|--------|--------|
| 구현 난이도 | 🟢 낮음 | 🔴 높음 | 🟢 낮음 | 🟡 중간 | 🟢 매우 낮음 |
| 배포 속도 | 🟡 보통 | 🟢 빠름 | 🟢 매우 빠름 | 🟢 즉시 | 🟡 지연 발생 |
| 보안성 | 🟡 SSH Key 노출 위험 | 🟢 내부망 | 🟢 SSH 불필요 | 🔴 Docker Socket Open | 🟢 Outbound Only |
| 리소스 사용 | 🟢 GitHub 자원 | 🔴 별도 서버 | 🟡 배포 서버 자원 | 🟢 없음 (로컬빌드 시) | 🟢 낮음 |

---

## 🎯 AI 추천

**추천 방안**: 방안 D (GitHub Actions Self-hosted Runner)

**이유**:
1.  **가장 안전하고 단순함**: SSH 키를 GitHub Secrets에 등록하고 외부 접속을 허용하는 과정 자체가 보안 리스크입니다. Self-hosted 방식은 이 문제를 원천적으로 해결합니다.
2.  **배포 속도 최적화**: Docker 이미지를 레지스트리에 푸시하고 다시 풀(Pull) 받는 네트워크 비용을 줄일 수 있습니다 (로컬 빌드 후 바로 실행 가능).
3.  **관리 포인트 최소화**: 복잡한 배포 스크립트 없이 로컬에서 하듯 `docker compose up`만 실행하면 됩니다.

**주의사항**:
- 서버 리소스 모니터링이 필요합니다.
- Runner는 프로젝트 전용(Repository Level)으로 등록하는 것을 권장합니다.

---

## ✅ 결정

> **선택한 방안**: [ ] 방안 A / [ ] 방안 B / [x] 방안 D
> 
> **결정 이유**: 보안성을 높이고 배포 파이프라인을 단순화하기 위해, SSH 접속 방식 대신 서버 내부에서 직접 실행되는 Self-hosted Runner 방식을 채택함.
> 
> **결정일**: 2026-01-10

---

## 🔜 다음 단계

결정 후:
1. `DO_002` 내용을 반영하여 `PLAN-002` 업데이트
2. 배포 서버에 GitHub Runner 설치 가이드 작성 및 실행
3. `.github/workflows/deploy.yml` 작성 (runs-on: self-hosted)
